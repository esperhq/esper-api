{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Esper API allows a two-way real time communication with the Esper Control Suite. It exposes all the functionality of the Esper Control Suite allowing you to create advanced script-driven routines for scanning. Languages This API wrapper is written for NodeJS using Socket.IO for communication There are Socket.IO bindings for most programming languages, so while the Esper API wrapper is written in Node.js, it is possible to write your own API wrapper in a language of your choice. See API in other programming languages for socket.IO endpoint information for creating your own wrapper. Installation Install with NPM using npm install esper-api Source code available on Github . Usage Required the Esper Control Suite to be running.","title":"Home"},{"location":"#home","text":"Esper API allows a two-way real time communication with the Esper Control Suite. It exposes all the functionality of the Esper Control Suite allowing you to create advanced script-driven routines for scanning.","title":"Home"},{"location":"#languages","text":"This API wrapper is written for NodeJS using Socket.IO for communication There are Socket.IO bindings for most programming languages, so while the Esper API wrapper is written in Node.js, it is possible to write your own API wrapper in a language of your choice. See API in other programming languages for socket.IO endpoint information for creating your own wrapper.","title":"Languages"},{"location":"#installation","text":"Install with NPM using npm install esper-api Source code available on Github .","title":"Installation"},{"location":"#usage","text":"Required the Esper Control Suite to be running.","title":"Usage"},{"location":"1-installingEsperAPI/","text":"Installing Esper API Prerequisites The Esper API wrapper is written in Node.js, in order to use it you will need to have a working installation of node on your machine along with a suitable package manager, npm or yarn are suitable. You can download Node.js here - we recommend you install the LTS version. To make sure Node.js is correctly installed, issue the command $ node -v This will tell you what verison of Node.js is installed on your machine. npm is distributed with Node.js so should be available to you once you've installed node. This can be verified with: $ npm -v If you wish to use yarn you can download it here Installation Before you start using the Esper API, you need to install it on the system you are using. You can start from scratch building the scripts you want by creating a new project or you can clone the Esper SDK to utilise a number of worked examples to get you started. Starting a new project from scratch If you want to start from scratch, create yourself a new npm project with the command if using NPM: $ npm init if using Yarn: $ yarn init Both of these options will guide you through creating your project. Once your project is created, install the Esper API with the following command: $ npm install esper-api or $ yarn install esper-api You can issue the same install command to add esper-api to an existing project. Cloning the Esper SDK The Esper SDK repository can be found on Github . To clone the SDK, issue the following command in a directory of your choosing; $ git clone https://github.com/esperhq/esper-sdk Once this has cloned, enter the new repository's directory $ cd ./esper-sdk This will clone the contents of the repository, now you need to install the project dependencies by issuing the install command $ npm install esper-api or $ yarn install esper-api","title":"Installing Esper API"},{"location":"1-installingEsperAPI/#installing-esper-api","text":"","title":"Installing Esper API"},{"location":"1-installingEsperAPI/#prerequisites","text":"The Esper API wrapper is written in Node.js, in order to use it you will need to have a working installation of node on your machine along with a suitable package manager, npm or yarn are suitable. You can download Node.js here - we recommend you install the LTS version. To make sure Node.js is correctly installed, issue the command $ node -v This will tell you what verison of Node.js is installed on your machine. npm is distributed with Node.js so should be available to you once you've installed node. This can be verified with: $ npm -v If you wish to use yarn you can download it here","title":"Prerequisites"},{"location":"1-installingEsperAPI/#installation","text":"Before you start using the Esper API, you need to install it on the system you are using. You can start from scratch building the scripts you want by creating a new project or you can clone the Esper SDK to utilise a number of worked examples to get you started.","title":"Installation"},{"location":"1-installingEsperAPI/#starting-a-new-project-from-scratch","text":"If you want to start from scratch, create yourself a new npm project with the command if using NPM: $ npm init if using Yarn: $ yarn init Both of these options will guide you through creating your project. Once your project is created, install the Esper API with the following command: $ npm install esper-api or $ yarn install esper-api You can issue the same install command to add esper-api to an existing project.","title":"Starting a new project from scratch"},{"location":"1-installingEsperAPI/#cloning-the-esper-sdk","text":"The Esper SDK repository can be found on Github . To clone the SDK, issue the following command in a directory of your choosing; $ git clone https://github.com/esperhq/esper-sdk Once this has cloned, enter the new repository's directory $ cd ./esper-sdk This will clone the contents of the repository, now you need to install the project dependencies by issuing the install command $ npm install esper-api or $ yarn install esper-api","title":"Cloning the Esper SDK"},{"location":"2-connectingToEsperAPI/","text":"Connecting to Esper API In order to use esper-api you must required it in any script you want to run. When you require it, the module exports a class the must be instantiated; const esperClass = require ( esper-api ); let Esper = new esperClass (); You can then connect to the API by calling the connect method like so: Esper . connect (); Constructor arguments The constructor for the Esper class takes three optional arguments. new esperClass ( verbose = true , endpoint = http://localhost , port = 50005 ); Verbose The first optional argument is a boolean that when set to true gives extended output on the console or reduced output when set to false. let Esper = new esperClass ( true ); // verbose output let Esper = new esperClass ( false ); // silences non-essential console output Remote connection You can specify which machine you wish to make a connection to, by default it will assume localhost, but if the controller box is connected to a remote pc, it is possible to specify that as an endpoint for the API wrapper to connect to let Esper = new esperClass ( true , http://192.168.1.54 ); // make connection to local machine on IP address 192.168.1.54 // (with verbose reporting as per the first argument) Port specification You can specify what port the API wrapper should use. This is useful if you have configured the Control Suite to run on a different port. For example you are already using port 50005 for something else or your network administration prohibits the use of that port let Esper = new esperClass ( true , http://localhost , 8080 ); // make connection on port 8080 //(with verbose reporting and connecting to localhost as per the first argument)","title":"Connecting to Esper API"},{"location":"2-connectingToEsperAPI/#connecting-to-esper-api","text":"In order to use esper-api you must required it in any script you want to run. When you require it, the module exports a class the must be instantiated; const esperClass = require ( esper-api ); let Esper = new esperClass (); You can then connect to the API by calling the connect method like so: Esper . connect ();","title":"Connecting to Esper API"},{"location":"2-connectingToEsperAPI/#constructor-arguments","text":"The constructor for the Esper class takes three optional arguments. new esperClass ( verbose = true , endpoint = http://localhost , port = 50005 );","title":"Constructor arguments"},{"location":"2-connectingToEsperAPI/#verbose","text":"The first optional argument is a boolean that when set to true gives extended output on the console or reduced output when set to false. let Esper = new esperClass ( true ); // verbose output let Esper = new esperClass ( false ); // silences non-essential console output","title":"Verbose"},{"location":"2-connectingToEsperAPI/#remote-connection","text":"You can specify which machine you wish to make a connection to, by default it will assume localhost, but if the controller box is connected to a remote pc, it is possible to specify that as an endpoint for the API wrapper to connect to let Esper = new esperClass ( true , http://192.168.1.54 ); // make connection to local machine on IP address 192.168.1.54 // (with verbose reporting as per the first argument)","title":"Remote connection"},{"location":"2-connectingToEsperAPI/#port-specification","text":"You can specify what port the API wrapper should use. This is useful if you have configured the Control Suite to run on a different port. For example you are already using port 50005 for something else or your network administration prohibits the use of that port let Esper = new esperClass ( true , http://localhost , 8080 ); // make connection on port 8080 //(with verbose reporting and connecting to localhost as per the first argument)","title":"Port specification"},{"location":"3-APIDesignPhilosophy/","text":"API Design Philosophy The design philosophy for the Esper API has focused on allowing the user to create real time, event driven scripts to expose the full functionality of the range of Esper products. To allow for fine-grained control of chained events, every method on the Esper API returns a promise that resolves when the requested action has been carried out or rejected upon an error. This allows for easy chaining of order-critical events, for example; const esperClass = require ( esper-api ); let Esper = new esperClass (); let sequencePayload = { }; //populated with correct information Esper . connect () . then ( Esper . checkRigFunctionality ) . then (()= { return Esper . globalModellingLight ([ 0 , 0.7 , 0 ]) }) . then (()= { return Esper . sequence ( sequencePayload ); }) . then ( Esper . trigger ) . then ( Esper . disconnect ) . catch ( Esper . describeErrors ); //handles any rejected promise in the chain If a method returns data, it will resolve its promise with the requested payload. More information on promises can be found in the MDN web docs","title":"API Design Philosophy"},{"location":"3-APIDesignPhilosophy/#api-design-philosophy","text":"The design philosophy for the Esper API has focused on allowing the user to create real time, event driven scripts to expose the full functionality of the range of Esper products. To allow for fine-grained control of chained events, every method on the Esper API returns a promise that resolves when the requested action has been carried out or rejected upon an error. This allows for easy chaining of order-critical events, for example; const esperClass = require ( esper-api ); let Esper = new esperClass (); let sequencePayload = { }; //populated with correct information Esper . connect () . then ( Esper . checkRigFunctionality ) . then (()= { return Esper . globalModellingLight ([ 0 , 0.7 , 0 ]) }) . then (()= { return Esper . sequence ( sequencePayload ); }) . then ( Esper . trigger ) . then ( Esper . disconnect ) . catch ( Esper . describeErrors ); //handles any rejected promise in the chain If a method returns data, it will resolve its promise with the requested payload. More information on promises can be found in the MDN web docs","title":"API Design Philosophy"},{"location":"4-rigSetupAndConfig/","text":"Rig Setup and Config Communication The ControllerBox handles all communication with the Multiflashes. Whenever you communicate with a Multiflash through the API, the ControllerBox is the device that is responsible for managing that communication. The computer needs to detect the ControllerBox, in order to achieve this, it sends a series of arbitrary bytes to every serial device connected on startup. An Esper ControllerBox is programmed to respond to these bytes with its version number. Once this has happened, the serial port is kept open and communication with the ControllerBox can begin. Configuration Loading in Rig Configuration The software needs to be given its configuration file to know what lights are connected and in which order. In order to do this, call the following method: Esper . saveConfiguration ( /path/to/my/configuration/file.txt ); //This will overwrite any previous settings This information will now be saved into the application's database for future reference. Exporting Rig Configuration Make a call to exportSettings() , this returns a promise that resolves with a json object the contains all the application settings. You can save this out as a .json file or stringify it and save it as a text file. Esper . exportSettings () . then (( theSettings )= { console . log ( theSettings ); //do something with them, maybe save to text file }); Startup Procedure Powering Up The following steps are to be followed to safely power up the rig; Ensure everything is plugged in correctly Make sure all connectors are plugged in firmly On each MultiFlash On every Neutrik connector on the Rack and Rig 240V connectors There must be no un-connected plugs Ensure the Emergency Stop button is pressed Turn on power at wall isolator Supply power to each PSU with the breakers on the back of the rack Ensure all PSUs show the red standby status light on the front Release the Emergency Stop button Ensure all PSUs now show the green status light on the front All connected MultiFlash units should now be powered Ensure all MultiFlashes are now showing a flashing green status light on the rear casing Software startup Connect the ControllerBox to the computer you have the Esper Control Suite installed on. Start the Esper Control Suite. This will automatically start the ControllerBox detection process. Once it has correctly detected a ControllerBox, the software will issue a success message. Calling the API With the Control Suite application successfully running, you can now execute your API scripts. Make sure the prerequisite modules are installed using npm install .","title":"Rig Setup and Config"},{"location":"4-rigSetupAndConfig/#rig-setup-and-config","text":"","title":"Rig Setup and Config"},{"location":"4-rigSetupAndConfig/#communication","text":"The ControllerBox handles all communication with the Multiflashes. Whenever you communicate with a Multiflash through the API, the ControllerBox is the device that is responsible for managing that communication. The computer needs to detect the ControllerBox, in order to achieve this, it sends a series of arbitrary bytes to every serial device connected on startup. An Esper ControllerBox is programmed to respond to these bytes with its version number. Once this has happened, the serial port is kept open and communication with the ControllerBox can begin.","title":"Communication"},{"location":"4-rigSetupAndConfig/#configuration","text":"","title":"Configuration"},{"location":"4-rigSetupAndConfig/#loading-in-rig-configuration","text":"The software needs to be given its configuration file to know what lights are connected and in which order. In order to do this, call the following method: Esper . saveConfiguration ( /path/to/my/configuration/file.txt ); //This will overwrite any previous settings This information will now be saved into the application's database for future reference.","title":"Loading in Rig Configuration"},{"location":"4-rigSetupAndConfig/#exporting-rig-configuration","text":"Make a call to exportSettings() , this returns a promise that resolves with a json object the contains all the application settings. You can save this out as a .json file or stringify it and save it as a text file. Esper . exportSettings () . then (( theSettings )= { console . log ( theSettings ); //do something with them, maybe save to text file });","title":"Exporting Rig Configuration"},{"location":"4-rigSetupAndConfig/#startup-procedure","text":"","title":"Startup Procedure"},{"location":"4-rigSetupAndConfig/#powering-up","text":"The following steps are to be followed to safely power up the rig; Ensure everything is plugged in correctly Make sure all connectors are plugged in firmly On each MultiFlash On every Neutrik connector on the Rack and Rig 240V connectors There must be no un-connected plugs Ensure the Emergency Stop button is pressed Turn on power at wall isolator Supply power to each PSU with the breakers on the back of the rack Ensure all PSUs show the red standby status light on the front Release the Emergency Stop button Ensure all PSUs now show the green status light on the front All connected MultiFlash units should now be powered Ensure all MultiFlashes are now showing a flashing green status light on the rear casing","title":"Powering Up"},{"location":"4-rigSetupAndConfig/#software-startup","text":"Connect the ControllerBox to the computer you have the Esper Control Suite installed on. Start the Esper Control Suite. This will automatically start the ControllerBox detection process. Once it has correctly detected a ControllerBox, the software will issue a success message.","title":"Software startup"},{"location":"4-rigSetupAndConfig/#calling-the-api","text":"With the Control Suite application successfully running, you can now execute your API scripts. Make sure the prerequisite modules are installed using npm install .","title":"Calling the API"},{"location":"5-multiflashFunctions/","text":"Multiflash Functions List Available Light Nodes This returns an array of light node objects each with associated metadata. Call it like so: Esper . getAvailableLights (). then (( lights )= { console . log ( lights ); }); This will print: [ { id : 1 , xyz : [ 0 , 0 , 0 ], ledPolarisation : [ horizontal , neutral , vertical ], line : 0 , address : 1 , maxFlashDuration : 30 , maxModellingLight : 0.03 , maxLightStages : 32 }, { id : 2 , xyz : [ 200 , 0 , 0 ], ledPolarisation : [ horizontal , neutral , vertical ], line : 0 , address : 2 , maxFlashDuration : 30 , maxModellingLight : 0.03 , maxLightStages : 32 }, //...and so on ] ``` Once this method has been called, the array of light node objects received is stored in the ` Esper . availableLights ` attribute. Each light node object has the following attributes: ``` javascript { id : 1 , //integer - used to uniquely identify a particular light on the rig xyz : [ 0 , 0 , 0 ], //physical location of that light node relative to the center of the dome in mm ledPolarisation : [ //describes the filters on each of the LEDs (i.e led 0 is horisontally polarized) horizontal , neutral , vertical ], line : 0 , //shows the data port on the controller box that this light is chained to address : 1 , //shows the address on the line that this light responds to maxFlashDuration : 50 , //maximum duration possible in milliseconds maxModellingLight : 3 , //maximum modelling light intensity in percentage points (i.e 3%) maxLightStages : 32 //maximum number of light stages the node can hold (sequence mode) }, Modelling Light The modelling light can be set in two different manners: Globally or Individually Global Modelling Light To set the modelling light globally (each light illuminated the same), choose what brightnesses you want for each LED, then pass this as an array to Esper.globalModellingLight() . For example: Esper . globalModellingLight ([ 1 , 3 , 0.5 ]); This would result in 1% brightness for the Horizontally polarised LED, 3% brightness for the Neutral LED and 0.5% brightness for the vertically polarised LED. The array indexes are the same as the ledPolarisation attribute on the light node object. Individual modelling light It is possible to set individual modelling light brightnesses on each light node. let modellingLightPayload = { id : 1 , intensities : [ 3 , 0 , 0 ]}; Esper . individualModellingLight ( modellingLightPayload ) calling Esper.individualModellingLight() only affects the light in question, allowing for very precise control over the static illumination of the rig Modelling light off To turn the modelling light off regardless of current configuration, use the command Esper . modellingLightOff (); Bullseye The bullseye method indicates to the subject where to look inside the dome. It achieves this by turning off the modelling light in a ring around the light node the subject should look at. Esper . bullseyeOn (); Esper . bullseyeOff (); Both of these methods return a promise so it would be possible to turn the bullseye on for 1 second with the following example Esper . bullseyeOn (). then (()= { setTimeout (()= { Esper . bullseyeOff (); }, 1000 ); });","title":"Multiflash Functions"},{"location":"5-multiflashFunctions/#multiflash-functions","text":"","title":"Multiflash Functions"},{"location":"5-multiflashFunctions/#list-available-light-nodes","text":"This returns an array of light node objects each with associated metadata. Call it like so: Esper . getAvailableLights (). then (( lights )= { console . log ( lights ); }); This will print: [ { id : 1 , xyz : [ 0 , 0 , 0 ], ledPolarisation : [ horizontal , neutral , vertical ], line : 0 , address : 1 , maxFlashDuration : 30 , maxModellingLight : 0.03 , maxLightStages : 32 }, { id : 2 , xyz : [ 200 , 0 , 0 ], ledPolarisation : [ horizontal , neutral , vertical ], line : 0 , address : 2 , maxFlashDuration : 30 , maxModellingLight : 0.03 , maxLightStages : 32 }, //...and so on ] ``` Once this method has been called, the array of light node objects received is stored in the ` Esper . availableLights ` attribute. Each light node object has the following attributes: ``` javascript { id : 1 , //integer - used to uniquely identify a particular light on the rig xyz : [ 0 , 0 , 0 ], //physical location of that light node relative to the center of the dome in mm ledPolarisation : [ //describes the filters on each of the LEDs (i.e led 0 is horisontally polarized) horizontal , neutral , vertical ], line : 0 , //shows the data port on the controller box that this light is chained to address : 1 , //shows the address on the line that this light responds to maxFlashDuration : 50 , //maximum duration possible in milliseconds maxModellingLight : 3 , //maximum modelling light intensity in percentage points (i.e 3%) maxLightStages : 32 //maximum number of light stages the node can hold (sequence mode) },","title":"List Available Light Nodes"},{"location":"5-multiflashFunctions/#modelling-light","text":"The modelling light can be set in two different manners: Globally or Individually","title":"Modelling Light"},{"location":"5-multiflashFunctions/#global-modelling-light","text":"To set the modelling light globally (each light illuminated the same), choose what brightnesses you want for each LED, then pass this as an array to Esper.globalModellingLight() . For example: Esper . globalModellingLight ([ 1 , 3 , 0.5 ]); This would result in 1% brightness for the Horizontally polarised LED, 3% brightness for the Neutral LED and 0.5% brightness for the vertically polarised LED. The array indexes are the same as the ledPolarisation attribute on the light node object.","title":"Global Modelling Light"},{"location":"5-multiflashFunctions/#individual-modelling-light","text":"It is possible to set individual modelling light brightnesses on each light node. let modellingLightPayload = { id : 1 , intensities : [ 3 , 0 , 0 ]}; Esper . individualModellingLight ( modellingLightPayload ) calling Esper.individualModellingLight() only affects the light in question, allowing for very precise control over the static illumination of the rig","title":"Individual modelling light"},{"location":"5-multiflashFunctions/#modelling-light-off","text":"To turn the modelling light off regardless of current configuration, use the command Esper . modellingLightOff ();","title":"Modelling light off"},{"location":"5-multiflashFunctions/#bullseye","text":"The bullseye method indicates to the subject where to look inside the dome. It achieves this by turning off the modelling light in a ring around the light node the subject should look at. Esper . bullseyeOn (); Esper . bullseyeOff (); Both of these methods return a promise so it would be possible to turn the bullseye on for 1 second with the following example Esper . bullseyeOn (). then (()= { setTimeout (()= { Esper . bullseyeOff (); }, 1000 ); });","title":"Bullseye"},{"location":"6-lightingTables/","text":"Lighting Profiles Before we can do anything with a rig of MultiFlash units, we have to give them some instructions about what to do. There are two modes the MultiFlashes can be in: 1. Chain Mode 2. Sequencer Mode Chain Mode Chain mode offers the user the ability to have fine-grained, multi-step directional lighting for the subject. Each individual MultiFlash can only flash once per take. In its longest form, this could be one light at a time, one after the other. It is possible to have more than one light illuminate per step giving a large number of creative options. Esper.chain() accepts an array of objects object as an argument. Each element in this array details what a particular light should do. An example of a single element is: { id : 1 , // ID of the light node stage : 2 , // the step on which this light is to flash. (this example, MultiFlash #1 will flash on the second exposure) intensities : [ 99 , 50 , 0 ], // Flash Illumination in tensities for each of the LEDs on the light node. (0-100 %) duration : 1.99 // Flash duration in ms. 0 flashDuration = 30 ms } An example of a full chain mode payload could look like this: let chainPayload = [ { id : 1 , stage : 1 , intensities : [ 100 , 0 , 0 ], duration : 5 , }, { id : 2 , stage : 2 , intensities : [ 0 , 100 , 0 ], duration : 5 , }, { id : 3 , stage : 2 , intensities : [ 0 , 0 , 100 ], duration : 5 , }, { id : 4 , stage : 3 , intensities : [ 100 , 100 , 100 ], duration : 10 , } ]; Esper . chain ( chainPayload ) . then (()= { console . log ( Chain mode data uploaded to the Light Nodes ); //ready to trigger }) . catch (( err )= { Esper . describeErrors ( err ); }); This example result in a lighting profile with 3 stages. In the first stage, only light node 1 flashes, on the second stage light nodes 2 and 3 flash, and the third and final stage is where light 4 flashes all three of its LEDs. Sequencer Mode Sequencer mode allows you to create complex lighting stages. Each light stage is independent from the one that came before it, so unlike chain mode, each light can flash on as many light stages as you like. There is a maximum of 32 light stages. The payload sent to the Esper.sequence(payload) method is an array of lighting stages. Each light stage has the following attributes: [ { id : 1 , intensities : [ 0 , 0 , 75.00 ], duration : 5.5 }, { id : 2 , intensities : [ 100 , 0 , 0 ], duration : 5.5 }, { id : 3 , intensities : [ 100 , 0 , 0 ], duration : 5 }, { id : 4 , intensities : [ 0 , 100 , 0 ], duration : 3 }, //... { id : 156 , intensities : [ 0 , 100 , 0 ], duration : 10.55 }, ] The ID parameter is the ID of the light, the intensities are the brighnesses you want each LED to flash at and the duration is the flash duration for that light in ms. Multiple light stages are then assembled into a full payload : let sequencePayload = [ [ // Stage 1 { id : 1 , intensities : [ 100 , 0 , 0 ], duration : 5.5 }, { id : 2 , intensities : [ 100 , 0 , 0 ], duration : 5 }, { id : 3 , intensities : [ 100 , 0 , 0 ], duration : 5 }, { id : 4 , intensities : [ 100 , 0 , 0 ], duration : 3 }, ... { id : 156 , intensities : [ 100 , 0 , 0 ], duration : 5.5 }, ], [ // Stage 2 { id : 1 , intensities : [ 0 , 100 , 0 ], duration : 5.5 }, { id : 2 , intensities : [ 0 , 100 , 0 ], duration : 5 }, { id : 3 , intensities : [ 0 , 100 , 0 ], duration : 5 }, { id : 4 , intensities : [ 0 , 100 , 0 ], duration : 3 }, ... { id : 156 , intensities : [ 0 , 100 , 0 ], duration : 10.55 }, ], //... so on up to a maximum of 32 stages ] Esper . sequence ( sequencePayload ) . then (()= { console . log ( Sequencer payload uploaded ); //then do other things }) . catch (( errs )= { Esper . describeErrors ( errs ); });","title":"Lighting Profiles"},{"location":"6-lightingTables/#lighting-profiles","text":"Before we can do anything with a rig of MultiFlash units, we have to give them some instructions about what to do. There are two modes the MultiFlashes can be in: 1. Chain Mode 2. Sequencer Mode","title":"Lighting Profiles"},{"location":"6-lightingTables/#chain-mode","text":"Chain mode offers the user the ability to have fine-grained, multi-step directional lighting for the subject. Each individual MultiFlash can only flash once per take. In its longest form, this could be one light at a time, one after the other. It is possible to have more than one light illuminate per step giving a large number of creative options. Esper.chain() accepts an array of objects object as an argument. Each element in this array details what a particular light should do. An example of a single element is: { id : 1 , // ID of the light node stage : 2 , // the step on which this light is to flash. (this example, MultiFlash #1 will flash on the second exposure) intensities : [ 99 , 50 , 0 ], // Flash Illumination in tensities for each of the LEDs on the light node. (0-100 %) duration : 1.99 // Flash duration in ms. 0 flashDuration = 30 ms } An example of a full chain mode payload could look like this: let chainPayload = [ { id : 1 , stage : 1 , intensities : [ 100 , 0 , 0 ], duration : 5 , }, { id : 2 , stage : 2 , intensities : [ 0 , 100 , 0 ], duration : 5 , }, { id : 3 , stage : 2 , intensities : [ 0 , 0 , 100 ], duration : 5 , }, { id : 4 , stage : 3 , intensities : [ 100 , 100 , 100 ], duration : 10 , } ]; Esper . chain ( chainPayload ) . then (()= { console . log ( Chain mode data uploaded to the Light Nodes ); //ready to trigger }) . catch (( err )= { Esper . describeErrors ( err ); }); This example result in a lighting profile with 3 stages. In the first stage, only light node 1 flashes, on the second stage light nodes 2 and 3 flash, and the third and final stage is where light 4 flashes all three of its LEDs.","title":"Chain Mode"},{"location":"6-lightingTables/#sequencer-mode","text":"Sequencer mode allows you to create complex lighting stages. Each light stage is independent from the one that came before it, so unlike chain mode, each light can flash on as many light stages as you like. There is a maximum of 32 light stages. The payload sent to the Esper.sequence(payload) method is an array of lighting stages. Each light stage has the following attributes: [ { id : 1 , intensities : [ 0 , 0 , 75.00 ], duration : 5.5 }, { id : 2 , intensities : [ 100 , 0 , 0 ], duration : 5.5 }, { id : 3 , intensities : [ 100 , 0 , 0 ], duration : 5 }, { id : 4 , intensities : [ 0 , 100 , 0 ], duration : 3 }, //... { id : 156 , intensities : [ 0 , 100 , 0 ], duration : 10.55 }, ] The ID parameter is the ID of the light, the intensities are the brighnesses you want each LED to flash at and the duration is the flash duration for that light in ms. Multiple light stages are then assembled into a full payload : let sequencePayload = [ [ // Stage 1 { id : 1 , intensities : [ 100 , 0 , 0 ], duration : 5.5 }, { id : 2 , intensities : [ 100 , 0 , 0 ], duration : 5 }, { id : 3 , intensities : [ 100 , 0 , 0 ], duration : 5 }, { id : 4 , intensities : [ 100 , 0 , 0 ], duration : 3 }, ... { id : 156 , intensities : [ 100 , 0 , 0 ], duration : 5.5 }, ], [ // Stage 2 { id : 1 , intensities : [ 0 , 100 , 0 ], duration : 5.5 }, { id : 2 , intensities : [ 0 , 100 , 0 ], duration : 5 }, { id : 3 , intensities : [ 0 , 100 , 0 ], duration : 5 }, { id : 4 , intensities : [ 0 , 100 , 0 ], duration : 3 }, ... { id : 156 , intensities : [ 0 , 100 , 0 ], duration : 10.55 }, ], //... so on up to a maximum of 32 stages ] Esper . sequence ( sequencePayload ) . then (()= { console . log ( Sequencer payload uploaded ); //then do other things }) . catch (( errs )= { Esper . describeErrors ( errs ); });","title":"Sequencer Mode"},{"location":"7-advancedControllerboxFunctions/","text":"Advanced Functions","title":"Advanced Functions"},{"location":"7-advancedControllerboxFunctions/#advanced-functions","text":"","title":"Advanced Functions"},{"location":"7-triggering/","text":"Triggering and synchronisation","title":"Triggering and synchronisation"},{"location":"7-triggering/#triggering-and-synchronisation","text":"","title":"Triggering and synchronisation"},{"location":"8-debugging/","text":"Debugging Reading MultiFlash IDs When the ControllerBox is detected, it will issue a command to any connected MultiFlashes to read their pre-programmed IDs. The MultiFlash status LED shows a solid green light when it has correctly read an ID from memory. It is possible to manually tell the MultiFlashes to read their ID Esper . loadLightNodeIDs (); First startup - Initial Configuration Initial setup will be carried out for you during installation and commissioning of your rig, however the information regarding the process of setting up a rig is documented here in the event you need to change your setup for any reason. The very first time an Esper MultiFlash starts up, it does not have an ID and needs to be assigned one. Each ID is unique to that particular MultiFlash and is the way you identify each MultiFlash when using the API. Each ID infers positional information of that light. IDs for a LightCage are assigned top to bottom in an anticlockwise fashion. We need to tell each MultiFlash to save its assigned ID into its EEPROM memory. Once this has happened, the lights will remember their ID when they start up every subsequent time. When the Esper Control Suite is opened, it goes through this process. If the ControllerBox is not found during this startup, you can request the software attempt to find the ControllerBox Esper . findControllerBox (); ~~In order to do this, we need to construct a NodeChain. This is the source of all information regarding the MultiFlashes that are connected to the ControllerBox. We need to tell the software what order the MultiFlashes are daisy-chained together.~~ Assigning MultiFlash IDs Now the application knows how many MultiFlashes are connected and in what order, it can assign IDs. You can do this with the following function. Esper . writeEEPROMAddresses (); /* Beware, if this function errors out, your rig may behave unpredictably or not respond at all until it successfully runs. Assigning IDs to lights is not something that is done often. */","title":"Debugging"},{"location":"8-debugging/#debugging","text":"","title":"Debugging"},{"location":"8-debugging/#reading-multiflash-ids","text":"When the ControllerBox is detected, it will issue a command to any connected MultiFlashes to read their pre-programmed IDs. The MultiFlash status LED shows a solid green light when it has correctly read an ID from memory. It is possible to manually tell the MultiFlashes to read their ID Esper . loadLightNodeIDs ();","title":"Reading MultiFlash IDs"},{"location":"8-debugging/#first-startup-initial-configuration","text":"Initial setup will be carried out for you during installation and commissioning of your rig, however the information regarding the process of setting up a rig is documented here in the event you need to change your setup for any reason. The very first time an Esper MultiFlash starts up, it does not have an ID and needs to be assigned one. Each ID is unique to that particular MultiFlash and is the way you identify each MultiFlash when using the API. Each ID infers positional information of that light. IDs for a LightCage are assigned top to bottom in an anticlockwise fashion. We need to tell each MultiFlash to save its assigned ID into its EEPROM memory. Once this has happened, the lights will remember their ID when they start up every subsequent time. When the Esper Control Suite is opened, it goes through this process. If the ControllerBox is not found during this startup, you can request the software attempt to find the ControllerBox Esper . findControllerBox (); ~~In order to do this, we need to construct a NodeChain. This is the source of all information regarding the MultiFlashes that are connected to the ControllerBox. We need to tell the software what order the MultiFlashes are daisy-chained together.~~","title":"First startup - Initial Configuration"},{"location":"8-debugging/#assigning-multiflash-ids","text":"Now the application knows how many MultiFlashes are connected and in what order, it can assign IDs. You can do this with the following function. Esper . writeEEPROMAddresses (); /* Beware, if this function errors out, your rig may behave unpredictably or not respond at all until it successfully runs. Assigning IDs to lights is not something that is done often. */","title":"Assigning MultiFlash IDs"},{"location":"9-closingTheConnection/","text":"Closing the Connection","title":"Closing the Connection"},{"location":"9-closingTheConnection/#closing-the-connection","text":"","title":"Closing the Connection"},{"location":"91-puttingItallTogether/","text":"Putting it all together","title":"Putting it all together"},{"location":"91-puttingItallTogether/#putting-it-all-together","text":"","title":"Putting it all together"},{"location":"92-usingOtherLanguages/","text":"API in other programming languages","title":"API in other programming languages"},{"location":"92-usingOtherLanguages/#api-in-other-programming-languages","text":"","title":"API in other programming languages"}]}